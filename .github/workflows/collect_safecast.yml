name: Collect SafeCast

on:
  schedule:
    - cron: "*/30 * * * *"   # каждые 30 минут
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: collect-safecast
  cancel-in-progress: false

jobs:
  collect:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          # Калининград
          - name: "Kaliningrad"
            file: "safecast_kaliningrad.json"
            lat:  "54.7104"
            lon:  "20.4522"
            dist: "50"      # км радиус
            hours: "48"     # глубина по времени

          # Кипр (Лимассол, охват южного побережья)
          - name: "Cyprus"
            file: "safecast_cyprus.json"
            lat:  "34.7071"
            lon:  "33.0226"
            dist: "100"     # км радиус
            hours: "72"     # глубина по времени

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Fetch SafeCast (${{ matrix.name }})
        env:
          OUT_FILE:  ${{ matrix.file }}
          LAT:       ${{ matrix.lat }}
          LON:       ${{ matrix.lon }}
          DIST:      ${{ matrix.dist }}
          HOURS:     ${{ matrix.hours }}
        run: |
          python - <<'PY'
          import os, json, time, math, datetime as dt
          from typing import List, Dict, Any, Optional, Tuple
          import requests

          out_file = os.environ["OUT_FILE"]
          lat = float(os.environ["LAT"]); lon = float(os.environ["LON"])
          dist_km = float(os.environ["DIST"]); hours = int(os.environ["HOURS"])

          since_dt = dt.datetime.utcnow() - dt.timedelta(hours=hours)
          since_iso = since_dt.strftime("%Y-%m-%dT%H:%M:%SZ")
          HEADERS = {"User-Agent": "VayboMeter/1.1 (+github-actions)"}

          def deg_per_km_lat() -> float: return 1/110.574
          def deg_per_km_lon(phi_deg: float) -> float: return 1/(111.320*math.cos(math.radians(phi_deg)))

          def bbox_from_center(lat, lon, km) -> Tuple[float,float,float,float]:
            dlat = km * deg_per_km_lat()
            dlon = km * deg_per_km_lon(lat)
            return (lat-dlat, lon-dlon, lat+dlat, lon+dlon)  # south, west, north, east

          def fetch(url: str, params: Dict[str, Any]) -> List[Dict[str, Any]]:
            items: List[Dict[str, Any]] = []
            per_page = 100
            for page in range(1, 51):
              p = dict(per_page=per_page, page=page)
              p.update(params)
              r = requests.get(url, params=p, headers=HEADERS, timeout=30)
              if r.status_code != 200:
                print(f"debug: GET {r.url} -> {r.status_code}")
                break
              try:
                batch = r.json()
              except Exception:
                print("debug: JSON parse error")
                break
              if not isinstance(batch, list) or not batch:
                break
              items.extend(batch)
              if len(batch) < per_page:
                break
              time.sleep(0.2)
            if items:
              print(f"debug: first_url={url} params_sample={params}")
            return items

          base_urls = [
            "https://api.safecast.org/measurements.json",
            "https://api.safecast.org/en-US/measurements.json",
          ]
          strategies: List[Tuple[str,Dict[str,Any]]] = []

          # distance: км, метры; с/без captured_after
          for u in base_urls:
            strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km, order="captured_at", direction="desc", captured_after=since_iso)))
            strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km*1000, order="captured_at", direction="desc", captured_after=since_iso)))
            strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km, order="captured_at", direction="desc")))
            strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km*1000, order="captured_at", direction="desc")))

          # bbox-режим
          s,w,n,e = bbox_from_center(lat, lon, dist_km)
          for u in base_urls:
            strategies.append((u, dict(north=n, south=s, east=e, west=w, order="captured_at", direction="desc", captured_after=since_iso)))
            strategies.append((u, dict(north=n, south=s, east=e, west=w, order="captured_at", direction="desc")))

          raw: List[Dict[str,Any]] = []
          used = None
          for url, params in strategies:
            raw = fetch(url, params)
            if raw:
              used = (url, params)
              break

          if not raw:
            with open(out_file, "w", encoding="utf-8") as f:
              json.dump([], f, ensure_ascii=False)
            print(f"safecast ({out_file}): no data fetched")
            raise SystemExit(0)

          def parse_ts(s: str) -> Optional[int]:
            try:
              if not s: return None
              if "." in s: s = s.split(".")[0] + "Z"
              return int(dt.datetime.fromisoformat(s.replace("Z","+00:00")).timestamp())
            except Exception:
              return None

          normalized: List[Dict[str,Any]] = []
          latest: Dict[str, Dict[str,Any]] = {}  # pm2.5 / pm10 -> {ts,value}
          for m in raw:
            cap = m.get("captured_at") or m.get("created_at") or ""
            ts = parse_ts(cap)
            if ts is None: continue
            vt = (m.get("value_type") or m.get("unit") or "").lower()
            try:
              val = float(m.get("value"))
            except Exception:
              continue
            rec = {
              "ts": ts,
              "lat": float(m.get("latitude") or 0),
              "lon": float(m.get("longitude") or 0),
              "value": val,
              "value_type": vt,
              "unit": m.get("unit"),
              "id": m.get("id"),
              "device": m.get("device") or m.get("device_id"),
              "source": "safecast",
            }
            normalized.append(rec)
            if vt in ("pm2.5","pm25","pm_2_5"):
              if "pm2.5" not in latest or ts > latest["pm2.5"]["ts"]:
                latest["pm2.5"] = {"ts": ts, "value": val}
            if vt in ("pm10","pm_10"):
              if "pm10" not in latest or ts > latest["pm10"]["ts"]:
                latest["pm10"] = {"ts": ts, "value": val}

          normalized.sort(key=lambda x: x["ts"])
          summary: Dict[str,Any] = {"records": normalized}
          t_candidates = [d["ts"] for d in latest.values()] or ([normalized[-1]["ts"]] if normalized else [])
          if t_candidates:
            summary["ts"] = max(t_candidates)
            summary["timestamp"] = dt.datetime.utcfromtimestamp(summary["ts"]).strftime("%Y-%m-%dT%H:%M:%SZ")
          if "pm2.5" in latest: summary["pm25"] = latest["pm2.5"]["value"]
          if "pm10"  in latest: summary["pm10"]  = latest["pm10"]["value"]

          with open(out_file, "w", encoding="utf-8") as f:
            json.dump(summary, f, ensure_ascii=False)

          n = len(normalized); pm25 = summary.get("pm25"); pm10 = summary.get("pm10")
          print(f"safecast ({out_file}): {n} raw records; pm25={pm25} pm10={pm10}; used={used}")
          PY

      - name: Commit & push if changed (${{ matrix.name }})
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if ! git diff --quiet -- ${{ matrix.file }}; then
            git add ${{ matrix.file }}
            git commit -m "safecast(${ { matrix.name } }): update ${{ matrix.file }}"
            git push
          else
            echo "No changes in ${{ matrix.file }}"
          fi