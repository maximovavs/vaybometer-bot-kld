name: Collect SafeCast

on:
  schedule:
    - cron: "*/30 * * * *"   # каждые 30 минут
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: collect-safecast
  cancel-in-progress: false

jobs:
  collect:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          # Калининград (радиус 300 км / 48 часов)
          - name: "Kaliningrad"
            file: "safecast_kaliningrad.json"
            lat:  "54.7104"
            lon:  "20.4522"
            dist: "300"     # км радиус
            hours: "48"     # глубина истории

          # Кипр (Лимассол и южное побережье, 100 км / 72 часа)
          - name: "Cyprus"
            file: "safecast_cyprus.json"
            lat:  "34.7071"
            lon:  "33.0226"
            dist: "100"     # км радиус
            hours: "72"     # глубина истории

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Fetch SafeCast (${{ matrix.name }})
        env:
          OUT_FILE:  ${{ matrix.file }}
          LAT:       ${{ matrix.lat }}
          LON:       ${{ matrix.lon }}
          DIST:      ${{ matrix.dist }}
          HOURS:     ${{ matrix.hours }}
        run: |
          python - <<'PY'
          import os, json, time, math
          import datetime as dt
          from typing import List, Dict, Any, Optional, Tuple
          import requests

          out_file = os.environ["OUT_FILE"]
          lat = float(os.environ["LAT"]); lon = float(os.environ["LON"])
          dist_km = float(os.environ["DIST"]); hours = int(os.environ["HOURS"])

          since_dt = dt.datetime.utcnow() - dt.timedelta(hours=hours)
          since_iso = since_dt.strftime("%Y-%m-%dT%H:%M:%SZ")
          HEADERS = {"User-Agent": "VayboMeter/1.3 (+github-actions)"}

          def fetch(url: str, params: Dict[str, Any]) -> List[Dict[str, Any]]:
              items: List[Dict[str, Any]] = []
              per_page = 100
              for page in range(1, 51):
                  p = dict(per_page=per_page, page=page)
                  p.update(params)
                  try:
                      r = requests.get(url, params=p, headers=HEADERS, timeout=30)
                  except requests.exceptions.RequestException:
                      break
                  if r.status_code != 200:
                      break
                  try:
                      batch = r.json()
                  except Exception:
                      break
                  if not isinstance(batch, list) or not batch:
                      break
                  items.extend(batch)
                  if len(batch) < per_page:
                      break
                  time.sleep(0.2)
              return items

          base_urls = [
              "https://api.safecast.org/measurements.json",
              "https://api.safecast.org/en-US/measurements.json",
          ]

          strategies: List[Tuple[str, Dict[str, Any]]] = []
          for u in base_urls:
              # distance — в км и в метрах; captured_after и его алиас since
              strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km,       order="captured_at", direction="desc", captured_after=since_iso)))
              strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km*1000,   order="captured_at", direction="desc", captured_after=since_iso)))
              strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km,       order="captured_at", direction="desc", since=since_iso)))
              strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km*1000,   order="captured_at", direction="desc", since=since_iso)))

          raw: List[Dict[str, Any]] = []
          used: Optional[Tuple[str, Dict[str, Any]]] = None

          # повторы всей последовательности стратегий при сетевых таймаутах
          for attempt in range(3):
              for url, params in strategies:
                  raw = fetch(url, params)
                  if raw:
                      used = (url, params)
                      break
              if raw:
                  break
              time.sleep(1.5 * (attempt + 1))

          def parse_ts(s: str) -> Optional[int]:
              try:
                  s = (s or "").strip()
                  if not s:
                      return None
                  # обрежем микросекунды
                  if "." in s:
                      s = s.split(".")[0] + "Z"
                  return int(dt.datetime.fromisoformat(s.replace("Z", "+00:00")).timestamp())
              except Exception:
                  return None

          normalized: List[Dict[str, Any]] = []
          for m in raw:
              ts = parse_ts(m.get("captured_at") or m.get("created_at"))
              if not ts or ts < int(since_dt.timestamp()):
                  continue
              val = m.get("value")
              try:
                  val = float(val)
              except Exception:
                  continue
              unit = (m.get("unit") or "").strip().lower()
              vt   = (m.get("value_type") or "").strip().lower()
              normalized.append({
                  "ts": ts,
                  "lat": float(m.get("latitude") or 0),
                  "lon": float(m.get("longitude") or 0),
                  "val": val,
                  "unit": unit,
                  "vt": vt,
                  "id": m.get("id"),
              })

          normalized.sort(key=lambda x: x["ts"])

          summary: Dict[str, Any] = {"ts": (normalized[-1]["ts"] if normalized else None)}

          def latest_by_vt(vt_name: str) -> Optional[Dict[str, Any]]:
              for d in reversed(normalized):
                  if d["vt"] == vt_name:
                      return d
              return None

          # PM
          pm25 = latest_by_vt("pm2.5")
          pm10 = latest_by_vt("pm10")
          if pm25: summary["pm25"] = pm25["val"]
          if pm10: summary["pm10"] = pm10["val"]

          # Радиация (медиана за 6 часов): приводим к μSv/h
          cut_ts = int((dt.datetime.utcnow() - dt.timedelta(hours=6)).timestamp())
          rvals: List[float] = []
          for d in normalized:
              if d["ts"] < cut_ts:
                  continue
              u = d["unit"]
              if "sv/h" in u or d["vt"] in ("usv/h","msv/h","radiation","radiation_usvh"):
                  v = d["val"]
                  if "msv/h" in u:
                      v *= 1000.0
                  rvals.append(v)
          if rvals:
              rvals.sort()
              n = len(rvals)
              summary["radiation_usvh"] = (rvals[n//2] if n % 2 else 0.5*(rvals[n//2-1] + rvals[n//2]))

          # CPM (медиана за 6 часов) — отдельная строка в посте
          cvals: List[float] = []
          for d in normalized:
              if d["ts"] < cut_ts:
                  continue
              if "cpm" in d["unit"] or d["vt"] == "cpm":
                  cvals.append(d["val"])
          if cvals:
              cvals.sort()
              n = len(cvals)
              summary["cpm"] = (cvals[n//2] if n % 2 else 0.5*(cvals[n//2-1] + cvals[n//2]))

          if used:
              summary["src"] = used[0]

          # Если вообще ничего не получили — пишем заглушку, чтобы пайплайн не падал
          if not normalized:
              with open(out_file, "w", encoding="utf-8") as f:
                  json.dump({"ts": None}, f, ensure_ascii=False)
          else:
              with open(out_file, "w", encoding="utf-8") as f:
                  json.dump(summary, f, ensure_ascii=False)

          print(
              f"safecast ({out_file}): {len(normalized)} raw; "
              f"pm25={summary.get('pm25')} pm10={summary.get('pm10')} "
              f"rad_usvh={summary.get('radiation_usvh')} cpm={summary.get('cpm')} "
              f"; used={used}"
          )
          PY

      - name: Commit & push if changed (${{ matrix.name }})
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if ! git diff --quiet -- ${{ matrix.file }}; then
            git add ${{ matrix.file }}
            git commit -m "safecast(${{ matrix.name }}): update ${{ matrix.file }}"
            git push
          else
            echo "No changes in ${{ matrix.file }}"
          fi