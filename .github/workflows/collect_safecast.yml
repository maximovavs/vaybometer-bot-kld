name: Collect SafeCast

on:
  schedule:
    - cron: "*/30 * * * *"
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: collect-safecast
  cancel-in-progress: false

jobs:
  collect:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          # Калининград (радиус 300 км)
          - name: "Kaliningrad"
            file: "safecast_kaliningrad.json"
            lat:  "54.7104"
            lon:  "20.4522"
            dist: "300"
            hours: "48"

          # Кипр (Лимассол)
          - name: "Cyprus"
            file: "safecast_cyprus.json"
            lat:  "34.7071"
            lon:  "33.0226"
            dist: "100"
            hours: "72"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Fetch SafeCast (${{ matrix.name }})
        env:
          OUT_FILE:  ${{ matrix.file }}
          LAT:       ${{ matrix.lat }}
          LON:       ${{ matrix.lon }}
          DIST:      ${{ matrix.dist }}
          HOURS:     ${{ matrix.hours }}
        run: |
          python - <<'PY'
          import os, json, time, math
          import datetime as dt
          from typing import List, Dict, Any, Optional, Tuple
          import requests
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          out_file = os.environ["OUT_FILE"]
          lat = float(os.environ["LAT"]); lon = float(os.environ["LON"])
          dist_km = float(os.environ["DIST"]); hours = int(os.environ["HOURS"])

          since_dt = dt.datetime.utcnow() - dt.timedelta(hours=hours)
          since_iso = since_dt.strftime("%Y-%m-%dT%H:%M:%SZ")
          HEADERS = {"User-Agent": "VayboMeter/1.3 (+github-actions)"}

          # Session с ретраями на сетевые ошибки/5xx
          sess = requests.Session()
          retry = Retry(
              total=4,
              backoff_factor=0.8,
              status_forcelist=(500, 502, 503, 504),
              allowed_methods=frozenset(["GET"])
          )
          sess.mount("https://", HTTPAdapter(max_retries=retry))
          TIMEOUT = (10, 90)  # connect, read

          def fetch_once(url: str, params: Dict[str, Any]) -> List[Dict[str, Any]]:
            items: List[Dict[str, Any]] = []
            per_page = 100
            for page in range(1, 51):
              p = dict(per_page=per_page, page=page)
              p.update(params)
              try:
                r = sess.get(url, params=p, headers=HEADERS, timeout=TIMEOUT)
              except Exception as e:
                print(f"debug: GET exception {e}")
                break
              if r.status_code != 200:
                print(f"debug: GET {r.url} -> {r.status_code}")
                break
              try:
                batch = r.json()
              except Exception:
                print("debug: JSON parse error")
                break
              if not isinstance(batch, list) or not batch:
                break
              items.extend(batch)
              if len(batch) < per_page:
                break
              time.sleep(0.2)
            return items

          def fetch_with_retries(url: str, params: Dict[str, Any], attempts: int = 3) -> List[Dict[str, Any]]:
            for i in range(1, attempts + 1):
              data = fetch_once(url, params)
              if data:
                return data
              if i < attempts:
                time.sleep((1,3,7)[i-1])
            return []

          base_urls = [
            "https://api.safecast.org/measurements.json",
            "https://api.safecast.org/en-US/measurements.json",
          ]
          strategies: List[Tuple[str, Dict[str, Any]]] = []
          for u in base_urls:
            strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km,     order="captured_at", direction="desc", captured_after=since_iso)))
            strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km*1000, order="captured_at", direction="desc", captured_after=since_iso)))
            strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km,     order="captured_at", direction="desc", since=since_iso)))
            strategies.append((u, dict(latitude=lat, longitude=lon, distance=dist_km*1000, order="captured_at", direction="desc", since=since_iso)))

          raw: List[Dict[str, Any]] = []
          used: Optional[Tuple[str, Dict[str, Any]]] = None
          for url, params in strategies:
            raw = fetch_with_retries(url, params)
            if raw:
              used = (url, params)
              break

          def parse_ts(s: str) -> Optional[int]:
            try:
              if "." in s: s = s.split(".")[0] + "Z"
              return int(dt.datetime.fromisoformat(s.replace("Z", "+00:00")).timestamp())
            except Exception:
              return None

          normalized: List[Dict[str, Any]] = []
          for m in raw:
            ts = parse_ts(m.get("captured_at") or m.get("created_at") or "")
            if not ts or ts < int(since_dt.timestamp()):
              continue
            unit = (m.get("unit") or "").strip()
            vt   = (m.get("value_type") or "").strip().lower()
            val  = m.get("value")
            try:
              val = float(val)
            except Exception:
              continue
            normalized.append({
              "ts": ts, "lat": float(m.get("latitude", 0)), "lon": float(m.get("longitude", 0)),
              "val": val, "unit": unit, "vt": vt, "id": m.get("id")
            })
          normalized.sort(key=lambda x: x["ts"])

          # summary (последние PM + медиана радиации за 6ч)
          summary: Dict[str, Any] = {"ts": (normalized[-1]["ts"] if normalized else None)}
          def latest_by_vt(vt_name: str) -> Optional[Dict[str, Any]]:
            for d in reversed(normalized):
              if d["vt"] == vt_name:
                return d
            return None
          pm25 = latest_by_vt("pm2.5"); pm10 = latest_by_vt("pm10")
          if pm25: summary["pm25"] = pm25["val"]
          if pm10: summary["pm10"] = pm10["val"]

          cut_ts = int((dt.datetime.utcnow() - dt.timedelta(hours=6)).timestamp())
          rad_vals = [d["val"] for d in normalized
                      if d["ts"] >= cut_ts and (("sv/h" in d["unit"].lower()) or d["vt"] in ("usv/h","radiation","radiation_usvh"))]
          if rad_vals:
            rad_vals.sort()
            n = len(rad_vals)
            med = rad_vals[n//2] if n % 2 else 0.5*(rad_vals[n//2-1] + rad_vals[n//2])
            summary["radiation"] = med

          # если вообще ничего не достали — сохраняем заглушку, но не падаем
          if not normalized:
            print("safecast: no data fetched (all endpoints/attempts failed); writing stub")
            with open(out_file, "w", encoding="utf-8") as f:
              json.dump({"ts": None}, f, ensure_ascii=False)
          else:
            with open(out_file, "w", encoding="utf-8") as f:
              json.dump(summary, f, ensure_ascii=False)

          print(f"safecast ({out_file}): {len(normalized)} raw; "
                f"pm25={summary.get('pm25')} pm10={summary.get('pm10')} "
                f"rad={summary.get('radiation')} ; used={used}")
          PY

      - name: Commit & push if changed (${{ matrix.name }})
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if ! git diff --quiet -- ${{ matrix.file }}; then
            git add ${{ matrix.file }}
            git commit -m "safecast(${{ matrix.name }}): update ${{ matrix.file }}"
            git push
          else
            echo "No changes in ${{ matrix.file }}"
          fi