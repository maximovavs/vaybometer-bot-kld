#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
gen_lunar_calendar.py ‚Äî –≥–µ–Ω–µ—Ä–∞—Ü–∏—è lunar_calendar.json (Gemini, –º–Ω–æ–≥–æ—Ä–∞—É–Ω–¥–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã, –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π VoC)

- –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–Ω—è —Å—á–∏—Ç–∞–µ—Ç —Ñ–∞–∑—É –õ—É–Ω—ã, –æ—Å–≤–µ—â—ë–Ω–Ω–æ—Å—Ç—å –∏ –∑–Ω–∞–∫;
- –¥–æ–±–∞–≤–ª—è–µ—Ç –∫–æ—Ä–æ—Ç–∫–∏–µ —Å–æ–≤–µ—Ç—ã (3 —Å—Ç—Ä–æ–∫–∏) –∏ –¥–ª–∏–Ω–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Ñ–∞–∑—ã —á–µ—Ä–µ–∑ Gemini;
- –µ—Å–ª–∏ —á–∞—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤ –Ω–µ –ø—Ä–∏—à–ª–∞, –¥–µ–ª–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –†–ê–£–ù–î–û–í –∑–∞–ø—Ä–æ—Å–æ–≤ —Å –ø–∞—É–∑–æ–π (–±–µ–∑ —Ñ–æ–ª–ª–±—ç–∫–æ–≤ –ø–æ—Å–µ—Ä–µ–¥–∏–Ω–µ);
- —Å—Ç—Ä–æ–≥–æ—Å—Ç—å —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è ENV: GEMINI_STRICT=1 ‚Äî —Ç–æ–ª—å–∫–æ Gemini, –±–µ–∑ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —Ñ–æ–ª–ª–±—ç–∫–æ–≤;
- —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç Void-of-Course: –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ç–æ—á–Ω–æ–≥–æ –º–∞–∂–æ—Ä–Ω–æ–≥–æ –∞—Å–ø–µ–∫—Ç–∞ –∫ –ø–ª–∞–Ω–µ—Ç–∞–º
  (0/60/90/120/180) –¥–æ –≤—Ö–æ–¥–∞ –õ—É–Ω—ã –≤ —Å–ª–µ–¥—É—é—â–∏–π –∑–Ω–∞–∫;
- –ø–∏—à–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ lunar_calendar.json.

–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: pendulum, pyswisseph, google-generativeai (–¥–ª—è Gemini).
"""

from __future__ import annotations
import os
import json
import math
import asyncio
import time
from pathlib import Path
from typing import Dict, Any, List, Tuple, Optional

import pendulum
import swisseph as swe

# –¢–∞–π–º–∑–æ–Ω–∞ –ø–æ–∫–∞–∑–∞
TZ = pendulum.timezone(os.getenv("LUNAR_TZ", "Asia/Nicosia"))

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ò–º–µ–Ω–∞ –∏ —ç–º–æ–¥–∑–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
EMO = {
    "–ù–æ–≤–æ–ª—É–Ω–∏–µ": "üåë",
    "–†–∞—Å—Ç—É—â–∏–π —Å–µ—Ä–ø": "üåí",
    "–ü–µ—Ä–≤–∞—è —á–µ—Ç–≤–µ—Ä—Ç—å": "üåì",
    "–†–∞—Å—Ç—É—â–∞—è –õ—É–Ω–∞": "üåî",
    "–ü–æ–ª–Ω–æ–ª—É–Ω–∏–µ": "üåï",
    "–£–±—ã–≤–∞—é—â–∞—è –õ—É–Ω–∞": "üåñ",
    "–ü–æ—Å–ª–µ–¥–Ω—è—è —á–µ—Ç–≤–µ—Ä—Ç—å": "üåó",
    "–£–±—ã–≤–∞—é—â–∏–π —Å–µ—Ä–ø": "üåò",
}
SIGNS = [
    "–û–≤–µ–Ω", "–¢–µ–ª–µ—Ü", "–ë–ª–∏–∑–Ω–µ—Ü—ã", "–†–∞–∫", "–õ–µ–≤", "–î–µ–≤–∞",
    "–í–µ—Å—ã", "–°–∫–æ—Ä–ø–∏–æ–Ω", "–°—Ç—Ä–µ–ª–µ—Ü", "–ö–æ–∑–µ—Ä–æ–≥", "–í–æ–¥–æ–ª–µ–π", "–†—ã–±—ã"
]

FALLBACK_LONG: Dict[str, str] = {
    "–ù–æ–≤–æ–ª—É–Ω–∏–µ":         "–ù—É–ª–µ–≤–∞—è —Ç–æ—á–∫–∞ —Ü–∏–∫–ª–∞ ‚Äî –∑–∞–∫–ª–∞–¥—ã–≤–∞–π—Ç–µ –º–µ—á—Ç—ã –∏ –Ω–∞–º–µ—Ä–µ–Ω–∏—è.",
    "–†–∞—Å—Ç—É—â–∏–π —Å–µ—Ä–ø":     "–≠–Ω–µ—Ä–≥–∏—è –ø—Ä–∏–±–∞–≤–ª—è–µ—Ç—Å—è ‚Äî –≤—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞—Ç—å –Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏.",
    "–ü–µ—Ä–≤–∞—è —á–µ—Ç–≤–µ—Ä—Ç—å":   "–ü–µ—Ä–≤—ã–µ —Ç—Ä—É–¥–Ω–æ—Å—Ç–∏ –ø—Ä–æ—è–≤–∏–ª–∏—Å—å, –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–π—Ç–µ –∫—É—Ä—Å –∏ –¥–µ–π—Å—Ç–≤—É–π—Ç–µ.",
    "–†–∞—Å—Ç—É—â–∞—è –õ—É–Ω–∞":     "–£—Å–∫–æ—Ä–µ–Ω–∏–µ: —Ä–∞—Å—à–∏—Ä—è–π—Ç–µ –ø—Ä–æ–µ–∫—Ç—ã, —É–∫—Ä–µ–ø–ª—è–π—Ç–µ —Å–≤—è–∑–∏.",
    "–ü–æ–ª–Ω–æ–ª—É–Ω–∏–µ":        "–ö—É–ª—å–º–∏–Ω–∞—Ü–∏—è: –º–∞–∫—Å–∏–º—É–º —ç–º–æ—Ü–∏–π –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.",
    "–£–±—ã–≤–∞—é—â–∞—è –õ—É–Ω–∞":    "–û—Ç–ø—É—Å–∫–∞–µ–º –ª–∏—à–Ω–µ–µ, –∑–∞–≤–µ—Ä—à–∞–µ–º –¥–µ–ª–∞, –Ω–∞–≤–æ–¥–∏–º –ø–æ—Ä—è–¥–æ–∫.",
    "–ü–æ—Å–ª–µ–¥–Ω—è—è —á–µ—Ç–≤–µ—Ä—Ç—å":"–ê–Ω–∞–ª–∏—Ç–∏–∫–∞, —Ä–µ—Ç—Ä–æ—Å–ø–µ–∫—Ç–∏–≤–∞ –∏ –ø–µ—Ä–µ—Å–º–æ—Ç—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏. –°–ø–æ–∫–æ–π–Ω–æ –∑–∞–≤–µ—Ä—à–∞–π—Ç–µ –Ω–∞—á–∞—Ç–æ–µ –∏ –ø–ª–∞–Ω–∏—Ä—É–π—Ç–µ —Å–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏.",
    "–£–±—ã–≤–∞—é—â–∏–π —Å–µ—Ä–ø":    "–û—Ç–¥—ã—Ö, —Ä–µ—Ç—Ä–∏—Ç—ã, –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ –Ω–æ–≤–æ–º—É —Ü–∏–∫–ª—É. –ë–µ—Ä–µ–∂–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–π—Ç–µ —Å–∏–ª—ã –∏ –æ—Å–≤–æ–±–æ–∂–¥–∞–π—Ç–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –¥–ª—è –Ω–æ–≤–æ–≥–æ.",
}

# –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ ¬´–±–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω—ã—Ö¬ª (–∫–∞–∫ –≤ –ø—Ä–µ–∂–Ω–∏—Ö –≤–µ—Ä—Å–∏—è—Ö)
CATS = {
    "general" :{"favorable":[2,3,9,27],   "unfavorable":[13,14,24]},
    "haircut" :{"favorable":[2,3,9],      "unfavorable":[]},
    "travel"  :{"favorable":[4,5],        "unfavorable":[]},
    "shopping":{"favorable":[1,2,7],      "unfavorable":[]},
    "health"  :{"favorable":[20,21,27],   "unfavorable":[]},
}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Gemini client ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
_GEMINI_MODEL = os.getenv("GEMINI_MODEL", "gemini-1.5-flash")
GEMINI_STRICT = os.getenv("GEMINI_STRICT", "0") == "1"

# –ª–∏–º–∏—Ç—ã/—Ä–∞—É–Ω–¥—ã (–Ω–∞—Å—Ç—Ä–∞–∏–≤–∞—é—Ç—Å—è –≤ workflow env)
GEMINI_CONCURRENCY    = int(os.getenv("GEMINI_CONCURRENCY", "3"))    # –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
GEMINI_MAX_ROUNDS     = int(os.getenv("GEMINI_MAX_ROUNDS", "4"))     # –º–∞–∫—Å–∏–º—É–º –≤–æ–ª–Ω (—Ä–∞—É–Ω–¥–æ–≤)
GEMINI_RETRY_ATTEMPTS = int(os.getenv("GEMINI_RETRY_ATTEMPTS", "2")) # —Ä–µ—Ç—Ä–∞–µ–≤ –≤–Ω—É—Ç—Ä–∏ –æ–¥–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
GEMINI_ROUND_PAUSE    = float(os.getenv("GEMINI_ROUND_PAUSE", "1.0"))# –ø–∞—É–∑–∞ –º–µ–∂–¥—É —Ä–∞—É–Ω–¥–∞–º–∏, —Å–µ–∫

_SEM = asyncio.Semaphore(GEMINI_CONCURRENCY)

def _get_gemini_model():
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        return None
    try:
        import google.generativeai as genai
        genai.configure(api_key=api_key)
        return genai.GenerativeModel(
            model_name=_GEMINI_MODEL,
            system_instruction=(
                "–¢—ã ‚Äî –∞—Å—Ç—Ä–æ–ª–æ–≥ —Å–æ —Å–ø–æ–∫–æ–π–Ω—ã–º, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–º —Å—Ç–∏–ª–µ–º; –ø–∏—à–µ—à—å –ø–æ-—Ä—É—Å—Å–∫–∏, "
                "–∫—Ä–∞—Ç–∫–æ –∏ –±–µ–∑ –ø—É–≥–∞—é—â–∏—Ö —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–æ–∫. –ë–µ–∑ –º–µ–¥–∏—Ü–∏–Ω—Å–∫–∏—Ö/—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å–æ–≤–µ—Ç–æ–≤."
            ),
            generation_config={
                "temperature": 0.65, "top_p": 0.9, "top_k": 40,
                "max_output_tokens": 400
            },
        )
    except Exception:
        return None

GM = _get_gemini_model()

async def _gemini_call(prompt: str) -> str:
    """–í—ã–∑–æ–≤ Gemini —Å —Ä–µ—Ç—Ä–∞—è–º–∏ –∏ —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–º backoff. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç (–º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º)."""
    if GM is None:
        return ""
    last_err = None
    for attempt in range(GEMINI_RETRY_ATTEMPTS + 1):
        try:
            r = await asyncio.to_thread(GM.generate_content, prompt)
            return (getattr(r, "text", "") or "").strip()
        except Exception as e:
            last_err = e
            time.sleep(0.6 * (2 ** attempt))  # 0.6s, 1.2s, ...
    return ""

def _split_lines(text: str) -> List[str]:
    out = []
    for raw in (text or "").splitlines():
        s = raw.strip().lstrip("-‚Ä¢‚Äî*0123456789. ").strip()
        if s:
            out.append(s)
    return out

# ‚Äî —Å–æ–≤–µ—Ç—ã (3 —Å—Ç—Ä–æ–∫–∏)
async def ai_get_advice_from_gemini(date_str: str, phase_name: str) -> List[str]:
    prompt = (
        f"–î–∞—Ç–∞: {date_str}. –§–∞–∑–∞ –õ—É–Ω—ã: {phase_name}. "
        "–î–∞–π 3 –æ—á–µ–Ω—å –∫–æ—Ä–æ—Ç–∫–∏—Ö —Å–æ–≤–µ—Ç–∞ (–ø–æ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ, –±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π) —Å —ç–º–æ–¥–∑–∏: "
        "1) üíº –ø—Ä–æ –¥–µ–ª–∞; 2) ‚õî —á—Ç–æ –ª—É—á—à–µ –æ—Ç–ª–æ–∂–∏—Ç—å; 3) ü™Ñ —Å–∞–º–æ–ø–æ–¥–¥–µ—Ä–∂–∫–∞."
    )
    async with _SEM:
        text = await _gemini_call(prompt)
    lines = _split_lines(text)[:3]
    return lines if len(lines) == 3 else []

# ‚Äî –¥–ª–∏–Ω–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Ñ–∞–∑—ã (1‚Äì2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)
async def ai_get_phase_long_from_gemini(phase_name: str, month_ru: str) -> str:
    prompt = (
        f"–ú–µ—Å—è—Ü: {month_ru}. –§–∞–∑–∞ –õ—É–Ω—ã: {phase_name}. "
        "–î–∞–π 1‚Äì2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è, –ø–æ–∑–∏—Ç–∏–≤–Ω–æ –∏ —Å–ø–æ–∫–æ–π–Ω–æ, –±–µ–∑ —ç–∑–æ—Ç–µ—Ä–∏–∫–∏ –∏ —Å–æ–≤–µ—Ç–æ–≤."
    )
    async with _SEM:
        txt = await _gemini_call(prompt)
    return (txt or "").strip()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ê—Å—Ç—Ä–æ–Ω–æ–º–∏—è ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
PLANETS = [
    swe.SUN, swe.MERCURY, swe.VENUS, swe.MARS, swe.JUPITER, swe.SATURN,
    swe.URANUS, swe.NEPTUNE, swe.PLUTO
]
ASPECTS = [0.0, 60.0, 90.0, 120.0, 180.0]

def _moon_lon(jd_ut: float) -> float:
    return swe.calc_ut(jd_ut, swe.MOON)[0][0] % 360.0

def _body_lon(jd_ut: float, body: int) -> float:
    return swe.calc_ut(jd_ut, body)[0][0] % 360.0

def _ang_diff(a: float, b: float) -> float:
    """–ü–æ–¥–ø–∏—Å–∞–Ω–Ω–∞—è —É–≥–ª–æ–≤–∞—è —Ä–∞–∑–Ω–æ—Å—Ç—å a-b –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [-180; 180]."""
    d = (a - b + 180.0) % 360.0 - 180.0
    return d

def _phase_angle(jd_ut: float) -> float:
    m = _moon_lon(jd_ut)
    s = _body_lon(jd_ut, swe.SUN)
    return (m - s) % 360.0

def phase_name_from_angle(angle: float) -> str:
    idx = int(((angle + 22.5) % 360.0) // 45.0)
    return [
        "–ù–æ–≤–æ–ª—É–Ω–∏–µ", "–†–∞—Å—Ç—É—â–∏–π —Å–µ—Ä–ø", "–ü–µ—Ä–≤–∞—è —á–µ—Ç–≤–µ—Ä—Ç—å", "–†–∞—Å—Ç—É—â–∞—è –õ—É–Ω–∞",
        "–ü–æ–ª–Ω–æ–ª—É–Ω–∏–µ", "–£–±—ã–≤–∞—é—â–∞—è –õ—É–Ω–∞", "–ü–æ—Å–ª–µ–¥–Ω—è—è —á–µ—Ç–≤–µ—Ä—Ç—å", "–£–±—ã–≤–∞—é—â–∏–π —Å–µ—Ä–ø"
    ][idx]

def illumination(angle: float) -> int:
    return int(round(50.0 * (1.0 - math.cos(math.radians(angle)))))

def zodiac_sign(jd_ut: float) -> str:
    lon = _moon_lon(jd_ut)
    return SIGNS[int(lon // 30)]

def _jd_to_pendulum(jd_ut: float) -> pendulum.DateTime:
    y, m, d, h = swe.revjul(jd_ut, swe.GREG_CAL)
    hour = float(h)
    hh = int(hour)
    mm = int((hour - hh) * 60.0)
    ss = int(((hour - hh) * 60.0 - mm) * 60.0)
    return pendulum.datetime(y, m, d, hh, mm, ss, tz="UTC")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–µ: –∏–Ω–≥—Äe—Å—Å –õ—É–Ω—ã –≤ —Å–ª–µ–¥—É—é—â–∏–π –∑–Ω–∞–∫ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _next_sign_ingress(jd_start: float) -> float:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç JD UTC –±–ª–∏–∂–∞–π—à–µ–≥–æ –≤—Ö–æ–¥–∞ –õ—É–Ω—ã –≤ —Å–ª–µ–¥—É—é—â–∏–π –∑–Ω–∞–∫ –æ—Ç jd_start."""
    lon0 = _moon_lon(jd_start)
    target = (math.floor(lon0 / 30.0) + 1) * 30.0 % 360.0
    if target <= lon0:
        target = (target + 30.0) % 360.0

    # –≥—Ä—É–±—ã–π —à–∞–≥ –≤–ø–µ—Ä—ë–¥ ‚Äî 1 —á–∞—Å
    step = 1.0 / 24.0
    t0 = jd_start
    for _ in range(200):
        lon = _moon_lon(t0)
        ahead = (target - lon) % 360.0
        if ahead < 1.0:
            break
        t0 += step

    # –±–∏–Ω–∞—Ä–Ω–æ–µ —É—Ç–æ—á–Ω–µ–Ω–∏–µ –¥–æ ~–º–∏–Ω—É—Ç—ã
    a = t0 - 2 * step
    b = t0 + 2 * step
    for _ in range(40):
        mid = 0.5 * (a + b)
        lon_mid = _moon_lon(mid)
        if (target - lon_mid) % 360.0 < 0.5:
            b = mid
        else:
            a = mid
    return 0.5 * (a + b)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ü–æ–∏—Å–∫ —Ç–æ—á–Ω–æ–≥–æ –º–∞–∂–æ—Ä–Ω–æ–≥–æ –∞—Å–ø–µ–∫—Ç–∞ –õ—É–Ω—ã –∫ –ø–ª–∞–Ω–µ—Ç–∞–º ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _aspect_function(jd_ut: float, body: int, aspect: float) -> float:
    """f(t) = signed( (Œª_Moon - Œª_body) - aspect ), —Å–≤–æ–¥–∏–º –≤ [-180;180]."""
    m = _moon_lon(jd_ut)
    p = _body_lon(jd_ut, body)
    return _ang_diff((m - p), aspect)

def _refine_root(a: float, b: float, body: int, asp: float) -> float:
    """–ë–∏—Å–µ–∫—Ü–∏—è –¥–æ —Ç–æ—á–Ω–æ—Å—Ç–∏ ~1 –º–∏–Ω."""
    for _ in range(40):
        m = 0.5 * (a + b)
        fm = _aspect_function(m, body, asp)
        if abs(fm) < 1e-4:
            return m
        fa = _aspect_function(a, body, asp)
        if fa * fm <= 0.0:
            b = m
        else:
            a = m
    return 0.5 * (a + b)

def _find_aspects_in_interval(jd_a: float, jd_b: float) -> List[float]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç JD —Ç–æ—á–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤ –õ—É–Ω—ã –∫ –ø–ª–∞–Ω–µ—Ç–∞–º –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [jd_a, jd_b]."""
    roots: List[float] = []
    step = 1.0 / 24.0  # 1 —á–∞—Å
    t = jd_a
    while t < jd_b:
        t_next = min(t + step, jd_b)
        for body in PLANETS:
            for asp in ASPECTS:
                f1 = _aspect_function(t, body, asp)
                f2 = _aspect_function(t_next, body, asp)
                if abs(f1) < 0.3:  # –ø–µ—Ä–≤–∏—á–Ω–∞—è –±–ª–∏–∑–æ—Å—Ç—å
                    roots.append(_refine_root(t - step, t + step, body, asp))
                elif f1 * f2 < 0.0:
                    roots.append(_refine_root(t, t_next, body, asp))
        t = t_next
    roots = sorted(set(round(r, 6) for r in roots))
    return roots

def compute_voc_window(jd_day_start: float) -> Optional[Tuple[float, float]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (jd_start, jd_end) VoC, –∫–æ—Ç–æ—Ä—ã–π –ü–ï–†–ï–°–ï–ö–ê–ï–¢ —Å—É—Ç–∫–∏, –Ω–∞—á–∏–Ω–∞—é—â–∏–µ—Å—è –≤ jd_day_start (UTC).
    –õ–æ–≥–∏–∫–∞: –±–µ—Ä—ë–º –±–ª–∏–∂–∞–π—à–∏–π –∏–Ω–≥—Äe—Å—Å –ø–æ—Å–ª–µ –ø–æ–ª—É–Ω–æ—á–∏ –∏ –∏—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ç–æ—á–Ω—ã–π –∞—Å–ø–µ–∫—Ç –¥–æ –Ω–µ–≥–æ
    –≤ –æ–∫–Ω–µ [ingress-3 —Å—É—Ç–æ–∫; ingress].
    """
    jd_ing = _next_sign_ingress(jd_day_start + 1.0/24.0)  # –ø–æ—Å–ª–µ –Ω–∞—á–∞–ª–∞ —Å—É—Ç–æ–∫
    jd_a = jd_ing - 3.0
    jd_b = jd_ing
    roots = _find_aspects_in_interval(jd_a, jd_b)
    last_aspect = max([r for r in roots if r < jd_ing], default=None)
    if last_aspect is None:
        return None

    voc_start = last_aspect
    voc_end   = jd_ing

    jd_day_end = jd_day_start + 1.0
    if voc_end <= jd_day_start or voc_start >= jd_day_end:
        return None
    return (max(voc_start, jd_day_start), min(voc_end, jd_day_end))

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û—Å–Ω–æ–≤–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def generate(year: int, month: int) -> Dict[str, Any]:
    start = pendulum.datetime(year, month, 1, tz="UTC")
    days = start.days_in_month

    cal: Dict[str, Any] = {}

    for dnum in range(1, days + 1):
        d = pendulum.datetime(year, month, dnum, tz="UTC")
        jd_mid = swe.julday(d.year, d.month, d.day, 12.0)
        ang = _phase_angle(jd_mid)
        ph_name = phase_name_from_angle(ang)
        illum = illumination(ang)
        sign = zodiac_sign(jd_mid)
        emoji = EMO[ph_name]
        phase_time = d.in_timezone(TZ).to_datetime_string()

        # VoC
        jd0 = swe.julday(d.year, d.month, d.day, 0.0)
        voc_jd = compute_voc_window(jd0)
        voc_ru = None
        if voc_jd:
            st_utc = _jd_to_pendulum(voc_jd[0]).in_timezone(TZ).to_datetime_string()
            en_utc = _jd_to_pendulum(voc_jd[1]).in_timezone(TZ).to_datetime_string()
            voc_ru = {"start": st_utc, "end": en_utc}

        key = d.to_date_string()
        cal[key] = {
            "phase_name": ph_name,
            "phase": f"{emoji} {ph_name}, {sign}",
            "percent": illum,
            "sign": sign,
            "phase_time": phase_time,
            "advice": [],          # <- –∑–∞–ø–æ–ª–Ω–∏–º –Ω–∏–∂–µ —á–µ—Ä–µ–∑ –º–Ω–æ–≥–æ—Ä–∞—É–Ω–¥–æ–≤—ã–π Gemini
            "long_desc": "",       # <- –∑–∞–ø–æ–ª–Ω–∏–º –Ω–∏–∂–µ —á–µ—Ä–µ–∑ –º–Ω–æ–≥–æ—Ä–∞—É–Ω–¥–æ–≤—ã–π Gemini
            "void_of_course": voc_ru,
            "favorable_days": CATS,
            "unfavorable_days": CATS,
        }

    # ‚îÄ‚îÄ –ú–ù–û–ì–û–†–ê–£–ù–î–û–í–´–ï –≤—ã–∑–æ–≤—ã Gemini ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # —Å–æ–±–∏—Ä–∞–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏
    pending_advice_days = sorted(cal.keys())
    pending_phase_names = sorted({rec["phase_name"] for rec in cal.values()})

    advice_results: Dict[str, List[str]] = {}
    long_results: Dict[str, str] = {}

    for round_idx in range(GEMINI_MAX_ROUNDS):
        # a) —Å–æ–≤–µ—Ç—ã –ø–æ –¥–Ω—è–º (—Ç–æ–ª—å–∫–æ —Ç–µ, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç)
        advice_tasks = []
        for day in pending_advice_days:
            rec = cal[day]
            phase_name = rec["phase_name"]
            advice_tasks.append(asyncio.create_task(ai_get_advice_from_gemini(day, phase_name)))
        if advice_tasks:
            advice_lists = await asyncio.gather(*advice_tasks)
            for day, lines in zip(pending_advice_days, advice_lists):
                if lines:
                    advice_results[day] = lines
            pending_advice_days = [d for d in pending_advice_days if d not in advice_results]

        # b) –¥–ª–∏–Ω–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã –ø–æ —Ñ–∞–∑–∞–º (—Ç–æ–ª—å–∫–æ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ)
        long_tasks = []
        for ph in pending_phase_names:
            # –Ω–∞–π–¥—ë–º –ª—é–±–æ–π –¥–µ–Ω—å —ç—Ç–æ–π —Ñ–∞–∑—ã –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –º–µ—Å—è—Ü–∞
            any_day = next(k for k, v in cal.items() if v["phase_name"] == ph)
            month_ru = pendulum.parse(any_day).format("MMMM")
            long_tasks.append(asyncio.create_task(ai_get_phase_long_from_gemini(ph, month_ru)))
        if long_tasks:
            long_texts = await asyncio.gather(*long_tasks)
            for ph, txt in zip(pending_phase_names, long_texts):
                if txt:
                    long_results[ph] = txt
            pending_phase_names = [ph for ph in pending_phase_names if ph not in long_results]

        # –µ—Å–ª–∏ –≤—Å—ë –ø–æ–ª—É—á–∏–ª–∏ ‚Äî –≤—ã—Ö–æ–¥–∏–º —Ä–∞–Ω—å—à–µ
        if not pending_advice_days and not pending_phase_names:
            break

        # –∏–Ω–∞—á–µ ‚Äî –Ω–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É —Ä–∞—É–Ω–¥–∞–º–∏
        await asyncio.sleep(GEMINI_ROUND_PAUSE)

    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ –æ—Ç Gemini
    for day, lines in advice_results.items():
        cal[day]["advice"] = lines
    for ph, txt in long_results.items():
        for rec in cal.values():
            if rec["phase_name"] == ph:
                cal_next = txt
                if not GEMINI_STRICT:
                    # –º—è–≥–∫–∞—è –ø–æ–¥—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ –¥–ª–∏–Ω—ã –≤ –ù–ï—Å—Ç—Ä–æ–≥–æ–º —Ä–µ–∂–∏–º–µ
                    if len(cal_next) < 80:
                        fb = FALLBACK_LONG.get(ph, "")
                        if cal_next:
                            sep = "" if cal_next.endswith(("!", "?", ".")) else ". "
                            cal_next = cal_next + sep + fb
                        else:
                            cal_next = fb
                rec["long_desc"] = cal_next

    # –î–æ–±–∏–≤–∞–µ–º –æ—Å—Ç–∞—Ç–∫–∏: strict ‚Üí –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—É—Å—Ç–æ; –∏–Ω–∞—á–µ ‚Äî –º—è–≥–∫–∏–µ —Ñ–æ–ª–ª–±—ç–∫–∏
    if not GEMINI_STRICT:
        # —Å–æ–≤–µ—Ç—ã
        for day in cal.keys():
            if not cal[day]["advice"]:
                cal[day]["advice"] = [
                    "üíº –°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ –≥–ª–∞–≤–Ω–æ–º.",
                    "‚õî –û—Ç–ª–æ–∂–∏—Ç–µ –∫—Ä—É–ø–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è.",
                    "ü™Ñ –ü—è—Ç—å –º–∏–Ω—É—Ç —Ç–∏—à–∏–Ω—ã –∏ –¥—ã—Ö–∞–Ω–∏—è.",
                ]
        # –¥–ª–∏–Ω–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã
        for ph in {rec["phase_name"] for rec in cal.values()}:
            have = any(rec["long_desc"] for rec in cal.values() if rec["phase_name"] == ph)
            if not have:
                fb = FALLBACK_LONG.get(ph, "")
                for rec in cal.values():
                    if rec["phase_name"] == ph:
                        rec["long_desc"] = fb

    return cal

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ entry-point ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def _main():
    # WORK_DATE –∏–∑ env –º–æ–∂–µ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è—Ç—å ¬´—Å–µ–≥–æ–¥–Ω—è¬ª (–∫–∞–∫ –≤ workflow)
    today = pendulum.today()
    data = await generate(today.year, today.month)
    Path("lunar_calendar.json").write_text(json.dumps(data, ensure_ascii=False, indent=2), "utf-8")
    print("‚úÖ lunar_calendar.json —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω")

if __name__ == "__main__":
    asyncio.run(_main())